# Quick Reference Guide - Suites Codebase

## Critical File Locations

### packages/core/src/services/
- **dependency-resolver.ts** - CORE: 9-level priority resolution algorithm (lines 66-142)
- **builders/sociable-unit-builder.ts** - Sociable mode with expose/boundaries modes
- **builders/solitary-unit-builder.ts** - Solitary mode (all mocked)
- **unit-mocker.ts** - Orchestrator for unit construction
- **unit-reference.ts** - Mock access validation (3 checks)
- **dependency-container.ts** - Pre-configured mock storage
- **dependency-map.ts** - Resolution cache

### packages/core/src/errors/
- **dependency-not-configured.error.ts** - Fail-fast error metadata

### packages/unit/src/
- **testbed.ts** - Public API (static solitary/sociable methods)
- **testbed-builder.ts** - Adapter resolution factory
- **package-resolver.ts** - Dynamic adapter loading

---

## Key Methods & Their Locations

### DependencyResolver.resolveOrMock() - THE HEART
**File**: `/Users/omer/projects/suites/suites/packages/core/src/services/dependency-resolver.ts`
**Lines**: 66-142
**Purpose**: Apply 9-level priority resolution

**Priority Hierarchy**:
1. Cache hit
2. Explicit mocks (.mock().impl/final)
3. Boundaries (if boundaries mode)
4. Tokens/primitives (ALWAYS mocked)
5. Auto-expose (if boundaries mode)
6. Explicitly exposed (if expose mode)
7. Fail-fast or auto-mock
8. Backward compat auto-mock
9. Fallback for non-functions

### DependencyResolver.isLeafOrPrimitive()
**File**: `/Users/omer/projects/suites/suites/packages/core/src/services/dependency-resolver.ts`
**Lines**: 46-51
**Purpose**: Detect tokens and primitives (no dependencies)

**Logic**:
```typescript
typeof identifier !== 'function' ||  // Is string/symbol token
this.adapter.inspect(identifier as Type).list().length === 0  // Has no dependencies
```

### SociableTestBedBuilder.compile()
**File**: `/Users/omer/projects/suites/suites/packages/core/src/services/builders/sociable-unit-builder.ts`
**Lines**: 189-275
**Purpose**: Build test environment with mode validation

**Key Steps**:
1. Merge .impl() and .final() configurations
2. Call UnitMocker.constructUnit() with resolver options
3. Process resolution summary for warnings
4. Include auto-exposed classes if boundaries mode
5. Return UnitTestBed

### UnitReference.get()
**File**: `/Users/omer/projects/suites/suites/packages/core/src/services/unit-reference.ts`
**Lines**: 80-141
**Purpose**: Controlled access to mocks

**Validation Order**:
1. Reject if faked (.final())
2. Reject if exposed (.expose())
3. Reject if not found
4. Return mock

---

## Mode Configurations

### Expose Mode (Whitelist)
```
classesToExpose: [Dep1, Dep2]      // These are REAL
boundaryClasses: []                 // Not used
autoExposeEnabled: false            // No auto-exposure
Default: MOCKED                     // Everything else
```

### Boundaries Mode (Blacklist)
```
classesToExpose: []                 // Not used
boundaryClasses: [Boundary1, ...]  // These are MOCKED
autoExposeEnabled: true             // Auto-expose non-boundaries
Default: REAL                       // Everything else
```

### Solitary Mode
```
mode: null
classesToExpose: []
boundaryClasses: []
failFastEnabled: false
autoExposeEnabled: false
Default: MOCKED                     // Everything
```

---

## Type System Enforcement

### Initial State
```
SociableTestBedBuilder<T>
├─ .expose() → SociableTestBedBuilderInExposeMode<T>  [boundaries() blocked]
└─ .boundaries() → SociableTestBedBuilderInBoundariesMode<T>  [expose() blocked]
```

This prevents mixing strategies at compile-time!

---

## Error Handling

### DependencyNotConfiguredError
- **When**: Fail-fast enabled + unconfigured dependency
- **Contains**: identifier, mode, configured exposes, configured boundaries
- **Location**: DependencyResolver line 123
- **Message**: Generated by SociableTestBedBuilder.formatDependencyNotConfiguredError()

### DependencyResolutionError
- **When**: Invalid access via unitRef.get()
- **Reasons**: Faked, exposed, or not found
- **Location**: UnitReference.get()

### AdapterNotFoundError
- **When**: Required DI or mocking adapter not installed
- **Location**: testBedBuilder.ts testBedBuilderFactory

---

## Key Data Structures

### ResolverOptions
```typescript
interface ResolverOptions {
  mode: 'expose' | 'boundaries' | null;
  boundaryClasses: Type[];
  failFastEnabled: boolean;
  autoExposeEnabled: boolean;
}
```

### MockedUnit<T>
```typescript
interface MockedUnit<TClass> {
  container: DependencyContainer;       // All mocked instances
  instance: TClass;                     // Unit under test
  resolution: {
    notFound: IdentifierToMockOrFinal[];
    mocks: { metadata?: unknown; identifier: Type }[];
    exposes: Type[];
  };
  autoExposedClasses: Type[];           // For boundaries mode
}
```

---

## Design Principles

1. **Immutability**: Options never mutated, all decisions from initial config
2. **No side effects**: Only caching in dependencyMap
3. **Idempotency**: Same identifier always returns same instance
4. **Priority-based**: 9-level hierarchy, first match wins
5. **Type-safe**: Interface progression prevents invalid states
6. **Single Responsibility**: Each class has one job
7. **Deferred error formatting**: Error metadata stored, messages generated at UI layer

---

## v4.0.0 vs v3.x

### Fail-Fast (Breaking Change)
- **v3.x**: `failFastEnabled: false` → undefined returned for unconfigured deps
- **v4.0.0**: `failFastEnabled: true` → DependencyNotConfiguredError thrown
- **Migration**: `.disableFailFast()` (deprecated, removed in v5.0)

### New: Boundaries Mode
- Blacklist testing strategy (opposite of expose)
- Auto-expose non-boundary dependencies
- Better for integration tests

### Improved: Error Messages
- Mode-aware suggestions
- Metadata included in error
- Single source of truth (formatDependencyNotConfiguredError)

---

## Compilation Flow

```
TestBed.solitary/sociable()
  ↓
testBedBuilderFactory (adapter resolution)
  ├─ Load DI adapter (NestJS/Inversify/Tsyringe)
  ├─ Load Doubles adapter (Jest/Sinon/Vitest/etc)
  └─ Create builder instance
    ↓
.mock(...).impl/final().mock(...).compile()
  ↓
SolitaryTestBedBuilder/SociableTestBedBuilder.compile()
  ├─ Create DependencyResolver
  ├─ Call instantiateClass() for target
  │  └─ Recursively resolveOrMock() dependencies
  ├─ Process resolution summary
  └─ Return UnitTestBed { unit, unitRef }
```

---

## Testing Patterns

### Pattern: Check if exposed
```typescript
if (typeof identifier === 'function' && this.classesToExpose.includes(identifier))
```

### Pattern: Check if boundary
```typescript
if (
  this.options.mode === 'boundaries' &&
  typeof identifier === 'function' &&
  this.options.boundaryClasses.includes(identifier)
)
```

### Pattern: Cache check
```typescript
if (this.dependencyMap.has(identifier)) {
  return this.dependencyMap.get(identifier);
}
```

### Pattern: Token detection
```typescript
if (this.isLeafOrPrimitive(identifier)) {
  // Always mock tokens
}
```

---

## File Statistics

- **core/src source**: 11 files (222 lines in resolver alone)
- **core/src tests**: 3 spec files
- **unit/src**: 5 files
- **Total lines**: ~1000+ across all files
- **Key focus**: DependencyResolver (the core engine)

---

## Common Gotchas

1. **Auto-expose only in boundaries mode**: expose mode doesn't auto-expose
2. **Tokens always mocked**: Even in expose/boundaries modes
3. **Fail-fast default**: v4.0.0 breaks v3.x tests with undefined deps
4. **Mode immutability**: Can't switch from expose to boundaries after first call
5. **Reference restrictions**: Can't access faked/exposed via unitRef
6. **Metadata matters**: Multiple same-ID deps matched by deep strict equality

